###############################################################################
# Auto-Deploy to Dev - Triggered when PR is merged to main
#
# Detects new migration files and automatically deploys them to dev environment
# with backup and rollback capabilities.
###############################################################################
name: Auto-Deploy to Dev

on:
  push:
    paths:
      - 'migrations/*.up.sql'
    branches: [main]

jobs:
  detect-and-deploy-dev:
    name: Deploy New Migrations to Dev
    runs-on: ubuntu-latest
    environment: dev
    outputs:
      new-migrations: ${{ steps.detect.outputs.files }}
      has-new-migrations: ${{ steps.detect.outputs.has-new }}
      backup-file: ${{ steps.backup.outputs.backup-file }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      
      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Detect new migration files
        id: detect
        run: |
          echo "üîç Detecting new migration files in merge..."
          NEW_FILES=$(git diff --name-only --diff-filter=A HEAD~1 HEAD | grep "migrations/.*\.up\.sql" || true)
          
          if [ -n "$NEW_FILES" ]; then
            echo "files<<EOF" >> $GITHUB_OUTPUT
            echo "$NEW_FILES" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "has-new=true" >> $GITHUB_OUTPUT
            echo "üÜï New migration files detected:"
            echo "$NEW_FILES" | while read file; do
              echo "  - $file"
            done
          else
            echo "has-new=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No new migration files detected"
            exit 0
          fi

      - name: Create pre-migration backup
        id: backup
        if: steps.detect.outputs.has-new == 'true'
        env:
          DB_HOST: sql12.freesqldatabase.com
          DB_PORT: 3306
          DB_USER: sql12817767
          DB_PASSWORD: Ajb7KukR9R
          DB_NAME: sql12817767
        run: |
          echo "üíæ Creating pre-migration backup for dev environment..."
          
          # Get migration IDs for backup naming
          NEW_FILES="${{ steps.detect.outputs.files }}"
          MIGRATION_IDS=""
          for file in $NEW_FILES; do
            ID=$(basename "$file" | cut -d'_' -f1)
            MIGRATION_IDS="${MIGRATION_IDS}_${ID}"
          done
          
          ts=$(date -u +%Y%m%d_%H%M%S)
          BACKUP_FILE="backups/dev_pre_migration${MIGRATION_IDS}_${ts}.sql"
          
          # Create backups directory
          mkdir -p backups
          
          mysqldump -h "$DB_HOST" -P "$DB_PORT" -u "$DB_USER" -p"$DB_PASSWORD" \
            --routines --triggers --events --single-transaction \
            "$DB_NAME" > "$BACKUP_FILE"
          
          echo "backup-file=$BACKUP_FILE" >> $GITHUB_OUTPUT
          echo "BACKUP_FILE=$BACKUP_FILE" >> $GITHUB_ENV
          echo "‚úÖ Backup created: $BACKUP_FILE"

      - name: Apply migrations to dev
        id: migrate
        if: steps.detect.outputs.has-new == 'true'
        env:
          DB_HOST: sql12.freesqldatabase.com
          DB_PORT: 3306
          DB_USER: sql12817767
          DB_PASSWORD: Ajb7KukR9R
          DB_NAME: sql12817767
        run: |
          echo "üöÄ Applying new migrations to dev environment..."
          
          # Show what will be applied
          echo "üìã Migrations to be applied:"
          python -m src.migrate status
          
          # Apply migrations with error handling
          if ! python -m src.migrate update --context dev; then
            echo "‚ùå Migration failed - executing auto-rollback..."
            mysql -h "$DB_HOST" -P "$DB_PORT" -u "$DB_USER" -p"$DB_PASSWORD" \
              "$DB_NAME" < "$BACKUP_FILE"
            echo "üîÑ Auto-rollback completed using $BACKUP_FILE"
            exit 1
          fi
          
          echo "‚úÖ Migrations applied successfully to dev!"

      - name: Run data pipeline
        if: steps.migrate.outcome == 'success'
        env:
          DB_HOST: sql12.freesqldatabase.com
          DB_PORT: 3306
          DB_USER: sql12817767
          DB_PASSWORD: Ajb7KukR9R
          DB_NAME: sql12817767
        run: |
          echo "üîÑ Running data pipeline in dev environment..."
          python -m src.pipeline run --env dev
          echo "‚úÖ Pipeline completed successfully!"

      - name: Verify migration integrity
        if: steps.migrate.outcome == 'success'
        env:
          DB_HOST: sql12.freesqldatabase.com
          DB_PORT: 3306
          DB_USER: sql12817767
          DB_PASSWORD: Ajb7KukR9R
          DB_NAME: sql12817767
        run: |
          echo "üîç Verifying migration integrity..."
          python -m src.migrate verify
          echo "‚úÖ Migration integrity verified!"

      - name: Upload backup to repository
        if: always() && steps.detect.outputs.has-new == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: dev-migration-backup-${{ github.run_id }}
          path: backups/dev_pre_migration_*.sql
          retention-days: 90

      - name: Commit backup to repository
        if: steps.migrate.outcome == 'success'
        run: |
          echo "üìÅ Committing backup file to repository..."
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add backups/
          git commit -m "Add dev migration backup: ${{ steps.backup.outputs.backup-file }}" || echo "No changes to commit"
          git push || echo "No changes to push"

      - name: Create success comment
        if: steps.migrate.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const newFiles = `${{ steps.detect.outputs.files }}`.split('\n').filter(f => f.trim());
            const backupFile = `${{ steps.backup.outputs.backup-file }}`;
            
            let comment = `## üöÄ Dev Deployment Successful!\n\n`;
            comment += `### ‚úÖ Migration Results\n`;
            comment += `- **Environment**: Development\n`;
            comment += `- **Status**: ‚úÖ Successfully Applied\n`;
            comment += `- **Backup Created**: \`${backupFile}\`\n`;
            comment += `- **Pipeline**: ‚úÖ Completed\n\n`;
            
            comment += `### üìÅ Applied Migration Files\n`;
            newFiles.forEach(file => {
              comment += `- \`${file}\`\n`;
            });
            
            comment += `\n### üéØ Next Steps for Production\n`;
            comment += `1. **Verify dev environment** is working correctly\n`;
            comment += `2. **Production CR** has been automatically created\n`;
            comment += `3. **Review and approve** the production deployment CR\n\n`;
            
            comment += `### üíæ Backup Information\n`;
            comment += `- **Location**: \`${backupFile}\`\n`;
            comment += `- **Retention**: 90 days\n`;
            comment += `- **Rollback**: Available via web UI or manual restore\n`;
            
            github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: comment
            });

      - name: Create automatic production CR
        if: steps.migrate.outcome == 'success'
        id: create-cr
        uses: actions/github-script@v7
        with:
          script: |
            const newFiles = `${{ steps.detect.outputs.files }}`.split('\n').filter(f => f.trim());
            const backupFile = `${{ steps.backup.outputs.backup-file }}`;
            const migrationIds = newFiles.map(file => {
              return file.split('/')[1].split('_')[0];
            }).join(',');
            
            // Generate CR number with timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const crNumber = `CR-${timestamp}`;
            
            let issueBody = `## üè≠ Production Deployment Change Request\n\n`;
            issueBody += `### üìã Change Request Details\n`;
            issueBody += `- **CR Number**: ${crNumber}\n`;
            issueBody += `- **Type**: Database Migration Deployment\n`;
            issueBody += `- **Priority**: Normal\n`;
            issueBody += `- **Requested By**: ${{ github.actor }}\n`;
            issueBody += `- **Dev Deployment**: ‚úÖ Completed Successfully\n`;
            issueBody += `- **Migration IDs**: ${migrationIds}\n\n`;
            
            issueBody += `### üìÅ Migration Files to Deploy\n`;
            newFiles.forEach(file => {
              issueBody += `- \`${file}\`\n`;
            });
            
            issueBody += `\n### ‚úÖ Dev Environment Validation\n`;
            issueBody += `- **Status**: ‚úÖ Successfully deployed and tested\n`;
            issueBody += `- **Backup Created**: \`${backupFile}\`\n`;
            issueBody += `- **Pipeline Tests**: ‚úÖ Passed\n`;
            issueBody += `- **Integrity Check**: ‚úÖ Verified\n\n`;
            
            issueBody += `### üéØ Production Deployment Plan\n`;
            issueBody += `1. **Pre-deployment backup** will be created automatically\n`;
            issueBody += `2. **Migration application** with auto-rollback on failure\n`;
            issueBody += `3. **Smoke tests** and integrity verification\n`;
            issueBody += `4. **Post-deployment monitoring** for 24 hours\n\n`;
            
            issueBody += `### üõ°Ô∏è Risk Assessment\n`;
            issueBody += `- **Risk Level**: Low (successfully tested in dev)\n`;
            issueBody += `- **Rollback Plan**: Automatic restoration from pre-migration backup\n`;
            issueBody += `- **Downtime**: Minimal (estimated < 5 minutes)\n`;
            issueBody += `- **Impact**: Database schema changes only\n\n`;
            
            issueBody += `### üìã Approval Checklist\n`;
            issueBody += `- [ ] **Dev testing completed** ‚úÖ (automatically verified)\n`;
            issueBody += `- [ ] **Business stakeholder approval**\n`;
            issueBody += `- [ ] **Technical lead approval**\n`;
            issueBody += `- [ ] **Production maintenance window scheduled**\n`;
            issueBody += `- [ ] **Rollback plan reviewed**\n\n`;
            
            issueBody += `### üöÄ Deployment Instructions\n`;
            issueBody += `Once approved, execute production deployment:\n\n`;
            issueBody += `1. Go to **Actions** ‚Üí **"Deploy to Production"**\n`;
            issueBody += `2. Click **"Run workflow"**\n`;
            issueBody += `3. Fill in the following inputs:\n`;
            issueBody += \`   - **Change Ticket ID**: \\\`${crNumber}\\\`\n\`;
            issueBody += \`   - **Migration IDs**: \\\`${migrationIds}\\\`\n\`;
            issueBody += `   - **Allow Destructive**: \`false\` (unless required)\n`;
            issueBody += `   - **Emergency Deployment**: \`false\`\n`;
            issueBody += `4. **Submit** and wait for approver to review\n`;
            issueBody += `5. **Approver** reviews and approves the deployment\n`;
            issueBody += `6. **Deployment** executes automatically\n\n`;
            
            issueBody += `### üìû Contacts\n`;
            issueBody += `- **Requestor**: @${{ github.actor }}\n`;
            issueBody += `- **Technical Lead**: [Assign appropriate person]\n`;
            issueBody += `- **On-call Engineer**: [Current on-call rotation]\n\n`;
            
            issueBody += `### üìä Deployment Artifacts\n`;
            issueBody += `- **Dev Backup**: \`${backupFile}\`\n`;
            issueBody += `- **Workflow Run**: [#${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})\n`;
            issueBody += `- **Commit SHA**: \`${{ github.sha }}\`\n\n`;
            
            issueBody += `---\n`;
            issueBody += `**This CR was automatically created after successful dev deployment.**\n`;
            issueBody += `**Approve this CR to proceed with production deployment.**`;
            
            // Create the issue
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üè≠ Production CR: Deploy Migrations ${migrationIds} (${crNumber})`,
              body: issueBody,
              labels: [
                'production-deployment',
                'change-request',
                'database-migration',
                'auto-generated'
              ],
              assignees: ['${{ github.actor }}']
            });
            
            console.log(`Created production CR: ${issue.data.html_url}`);
            return issue.data.number;

      - name: Add CR link to commit comment
        if: steps.migrate.outcome == 'success' && steps.create-cr.outputs.result
        uses: actions/github-script@v7
        with:
          script: |
            const crNumber = `${{ steps.create-cr.outputs.result }}`;
            const crUrl = `${{ github.server_url }}/${{ github.repository }}/issues/${crNumber}`;
            
            let followupComment = `\n### üé´ Production Change Request Created\n`;
            followupComment += `**CR #${crNumber}**: [Production Deployment Request](${crUrl})\n\n`;
            followupComment += `**Next Steps:**\n`;
            followupComment += `1. Review the CR for production deployment details\n`;
            followupComment += `2. Assign appropriate approvers\n`;
            followupComment += `3. Schedule maintenance window if needed\n`;
            followupComment += `4. Approve CR to proceed with production deployment\n`;
            
            github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: followupComment
            });