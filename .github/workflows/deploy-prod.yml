###############################################################################
# Production Deploy Workflow ‚Äî Manual trigger with Change Request
#
# Requires manual approval and change ticket for production deployment.
# Creates comprehensive backups, applies migrations, and provides rollback.
###############################################################################
name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      change_ticket_id:
        description: "Change Request / Ticket ID (required for audit)"
        required: true
        type: string
      migration_ids:
        description: "Migration IDs to deploy (e.g., 011,012,013)"
        required: true
        type: string
      allow_destructive:
        description: "Allow destructive SQL operations (DROP, TRUNCATE, etc.)"
        required: false
        type: boolean
        default: false
      emergency_deployment:
        description: "Emergency deployment (skip some safety checks)"
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  pre-deployment-checks:
    name: Pre-Deployment Validation
    runs-on: ubuntu-latest
    outputs:
      migration-list: ${{ steps.validate.outputs.migration-list }}
      
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Validate deployment request
        id: validate
        run: |
          echo "üîç Validating production deployment request..."
          echo "Change Ticket: ${{ inputs.change_ticket_id }}"
          echo "Migration IDs: ${{ inputs.migration_ids }}"
          echo "Allow Destructive: ${{ inputs.allow_destructive }}"
          echo "Emergency: ${{ inputs.emergency_deployment }}"
          
          # Validate migration IDs exist
          IFS=',' read -ra MIGRATION_ARRAY <<< "${{ inputs.migration_ids }}"
          MIGRATION_LIST=""
          for id in "${MIGRATION_ARRAY[@]}"; do
            id=$(echo "$id" | xargs)  # trim whitespace
            FILE="migrations/${id}_*.up.sql"
            if ls $FILE 1> /dev/null 2>&1; then
              ACTUAL_FILE=$(ls $FILE)
              echo "‚úÖ Found migration: $ACTUAL_FILE"
              MIGRATION_LIST="$MIGRATION_LIST $ACTUAL_FILE"
            else
              echo "‚ùå Migration file not found for ID: $id"
              exit 1
            fi
          done
          
          echo "migration-list=$MIGRATION_LIST" >> $GITHUB_OUTPUT
          echo "‚úÖ All requested migrations found"

      - name: Check for destructive operations
        if: inputs.allow_destructive == false
        run: |
          echo "üîç Checking for destructive operations..."
          MIGRATION_LIST="${{ steps.validate.outputs.migration-list }}"
          
          for file in $MIGRATION_LIST; do
            if grep -q "DROP TABLE\|DROP DATABASE\|TRUNCATE\|DELETE FROM" "$file"; then
              echo "‚ùå Destructive operation found in $file but allow_destructive is false"
              echo "Set allow_destructive to true or remove destructive operations"
              exit 1
            fi
          done
          
          echo "‚úÖ No destructive operations found"

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    environment: prod          # <-- requires GitHub Environment "prod" with reviewers

    env:
      DB_HOST:           ${{ secrets.PROD_DB_HOST }}
      DB_PORT:           ${{ secrets.PROD_DB_PORT }}
      DB_USER:           ${{ secrets.PROD_DB_USER }}
      DB_PASSWORD:       ${{ secrets.PROD_DB_PASSWORD }}
      DB_NAME:           ${{ secrets.PROD_DB_NAME }}
      ENV_NAME:          prod
      ALLOW_DESTRUCTIVE: ${{ inputs.allow_destructive }}
      GRACEFUL_MIGRATIONS: true

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Log deployment metadata
        run: |
          echo "=========================================="
          echo "         PRODUCTION DEPLOYMENT"
          echo "=========================================="
          echo "Change Ticket    : ${{ inputs.change_ticket_id }}"
          echo "Migration IDs    : ${{ inputs.migration_ids }}"
          echo "Destructive Ops  : ${{ inputs.allow_destructive }}"
          echo "Emergency Deploy : ${{ inputs.emergency_deployment }}"
          echo "Deployed By      : ${{ github.actor }}"
          echo "Repository SHA   : ${{ github.sha }}"
          echo "Timestamp        : $(date -u)"
          echo "=========================================="

      - name: Create comprehensive backup
        id: backup
        run: |
          echo "üíæ Creating comprehensive pre-migration backup..."
          
          # Create backup filename with migration IDs
          MIGRATION_IDS="${{ inputs.migration_ids }}"
          CLEAN_IDS=$(echo "$MIGRATION_IDS" | tr ',' '_')
          ts=$(date -u +%Y%m%d_%H%M%S)
          BACKUP_FILE="backups/prod_pre_migration_${CLEAN_IDS}_${ts}.sql"
          
          # Create backups directory
          mkdir -p backups
          
          mysqldump -h "$DB_HOST" -P "$DB_PORT" -u "$DB_USER" -p"$DB_PASSWORD" \
            --single-transaction --no-tablespaces --skip-triggers --skip-events --add-drop-table --complete-insert \
            "$DB_NAME" > "$BACKUP_FILE"
          
          echo "backup-file=$BACKUP_FILE" >> $GITHUB_OUTPUT
          echo "BACKUP_FILE=$BACKUP_FILE" >> $GITHUB_ENV
          echo "‚úÖ Backup created: $BACKUP_FILE"
          
          # Create backup metadata
          cat > "${BACKUP_FILE}.meta" << EOF
          {
            "timestamp": "$(date -u)",
            "change_ticket": "${{ inputs.change_ticket_id }}",
            "migration_ids": "${{ inputs.migration_ids }}",
            "deployed_by": "${{ github.actor }}",
            "repository_sha": "${{ github.sha }}",
            "backup_size": "$(stat -c%s "$BACKUP_FILE")"
          }
          EOF

      - name: Show pending migrations
        run: |
          echo "üìã Migrations to be applied to production:"
          python -m src.migrate status

      - name: Apply migrations to production
        id: migrate
        run: |
          echo "üöÄ Applying migrations to production environment..."
          
          if ! python -m src.migrate update --context prod; then
            echo "‚ùå Migration application failed!"
            exit 1
          fi
          
          echo "‚úÖ Migrations applied successfully to production!"

      - name: Auto-rollback on migration failure
        if: failure() && steps.migrate.outcome == 'failure'
        run: |
          echo "::error::PRODUCTION migration failed ‚Äî executing emergency rollback"
          echo "Restoring from backup: $BACKUP_FILE"
          
          mysql -h "$DB_HOST" -P "$DB_PORT" -u "$DB_USER" -p"$DB_PASSWORD" \
            "$DB_NAME" < "$BACKUP_FILE"
          
          echo ""
          echo "=========================================="
          echo "         EMERGENCY ROLLBACK COMPLETE"
          echo "=========================================="
          echo "Database restored to pre-migration state"
          echo "Change Ticket: ${{ inputs.change_ticket_id }}"
          echo "Backup Used: $BACKUP_FILE"
          echo "Rollback Time: $(date -u)"
          echo ""
          echo "üö® IMMEDIATE ACTION REQUIRED:"
          echo "1. Verify application health and functionality"
          echo "2. Check ops_migration_runs for failure details"
          echo "3. Notify stakeholders of rollback"
          echo "4. Create incident ticket if not exists"
          echo "5. Fix migration issues before retry"
          echo "=========================================="

      - name: Run production smoke tests
        if: steps.migrate.outcome == 'success'
        run: |
          echo "üß™ Running production smoke tests..."
          python -m src.pipeline run --env prod
          echo "‚úÖ Smoke tests completed!"

      - name: Verify migration integrity
        if: steps.migrate.outcome == 'success'
        run: |
          echo "üîç Verifying production migration integrity..."
          python -m src.migrate verify
          echo "‚úÖ Migration integrity verified!"

      - name: Upload backup artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: prod-migration-backup-${{ github.run_id }}
          path: |
            backups/prod_pre_migration_*.sql
            backups/prod_pre_migration_*.sql.meta
          retention-days: 365

      - name: Commit backup to repository
        if: steps.migrate.outcome == 'success'
        run: |
          echo "üìÅ Committing production backup to repository..."
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action - Production Deploy"
          git add backups/
          git commit -m "Add production migration backup: ${{ steps.backup.outputs.backup-file }} (CR: ${{ inputs.change_ticket_id }})" || echo "No changes to commit"
          git push || echo "No changes to push"

      - name: Create deployment summary
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const success = '${{ steps.migrate.outcome }}' === 'success';
            const backupFile = '${{ steps.backup.outputs.backup-file }}';
            const changeTicket = '${{ inputs.change_ticket_id }}';
            const migrationIds = '${{ inputs.migration_ids }}';
            
            let summary = `## üè≠ Production Deployment ${success ? 'Completed' : 'Failed'}\n\n`;
            summary += `### üìã Deployment Details\n`;
            summary += `- **Change Ticket**: ${changeTicket}\n`;
            summary += `- **Migration IDs**: ${migrationIds}\n`;
            summary += `- **Status**: ${success ? '‚úÖ Success' : '‚ùå Failed'}\n`;
            summary += `- **Deployed By**: ${{ github.actor }}\n`;
            summary += `- **Timestamp**: ${new Date().toISOString()}\n\n`;
            
            if (success) {
              summary += `### ‚úÖ Deployment Successful\n`;
              summary += `- **Migrations Applied**: Successfully\n`;
              summary += `- **Smoke Tests**: ‚úÖ Passed\n`;
              summary += `- **Integrity Check**: ‚úÖ Verified\n`;
              summary += `- **Backup Created**: \`${backupFile}\`\n\n`;
              summary += `### üéØ Post-Deployment Tasks\n`;
              summary += `1. Monitor application health for 24 hours\n`;
              summary += `2. Update change ticket with completion status\n`;
              summary += `3. Notify stakeholders of successful deployment\n`;
              summary += `4. Archive deployment artifacts\n`;
            } else {
              summary += `### ‚ùå Deployment Failed - Rollback Executed\n`;
              summary += `- **Rollback Status**: ‚úÖ Completed\n`;
              summary += `- **Backup Used**: \`${backupFile}\`\n`;
              summary += `- **Database State**: Restored to pre-migration\n\n`;
              summary += `### üö® Required Actions\n`;
              summary += `1. Verify application functionality immediately\n`;
              summary += `2. Create/update incident ticket\n`;
              summary += `3. Investigate migration failure cause\n`;
              summary += `4. Fix issues before retry\n`;
              summary += `5. Notify all stakeholders\n`;
            }
            
            summary += `\n### üíæ Backup Information\n`;
            summary += `- **File**: \`${backupFile}\`\n`;
            summary += `- **Retention**: 365 days\n`;
            summary += `- **Location**: Repository backups/ folder + Artifacts\n`;
            
            github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: summary
            });

      - name: Update production CR status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const success = '${{ steps.migrate.outcome }}' === 'success';
            const changeTicket = '${{ inputs.change_ticket_id }}';
            const migrationIds = '${{ inputs.migration_ids }}';
            
            // Find the CR issue by searching for the change ticket ID
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'production-deployment,change-request',
              state: 'open'
            });
            
            // Find the matching CR by title or body content
            const matchingIssue = issues.data.find(issue => 
              issue.title.includes(migrationIds) || 
              issue.body.includes(changeTicket)
            );
            
            if (matchingIssue) {
              let updateComment = `## üè≠ Production Deployment Update\n\n`;
              
              if (success) {
                updateComment += `### ‚úÖ Deployment Completed Successfully\n`;
                updateComment += `- **Status**: Production deployment completed\n`;
                updateComment += `- **Migration IDs**: ${migrationIds}\n`;
                updateComment += `- **Deployed By**: ${{ github.actor }}\n`;
                updateComment += `- **Completion Time**: ${new Date().toISOString()}\n`;
                updateComment += `- **Smoke Tests**: ‚úÖ Passed\n`;
                updateComment += `- **Integrity Check**: ‚úÖ Verified\n\n`;
                updateComment += `### üìã Post-Deployment Actions\n`;
                updateComment += `- [ ] Monitor application health (24 hours)\n`;
                updateComment += `- [ ] Verify business functionality\n`;
                updateComment += `- [ ] Update stakeholders\n`;
                updateComment += `- [ ] Archive deployment artifacts\n\n`;
                updateComment += `**This CR can now be closed as the deployment is complete.**`;
                
                // Add success label and close the issue
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: matchingIssue.number,
                  labels: ['deployment-success', 'completed']
                });
                
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: matchingIssue.number,
                  state: 'closed'
                });
                
              } else {
                updateComment += `### ‚ùå Deployment Failed - Rollback Executed\n`;
                updateComment += `- **Status**: Production deployment failed\n`;
                updateComment += `- **Migration IDs**: ${migrationIds}\n`;
                updateComment += `- **Attempted By**: ${{ github.actor }}\n`;
                updateComment += `- **Failure Time**: ${new Date().toISOString()}\n`;
                updateComment += `- **Rollback**: ‚úÖ Completed successfully\n`;
                updateComment += `- **Database State**: Restored to pre-migration\n\n`;
                updateComment += `### üö® Required Actions\n`;
                updateComment += `- [ ] Verify application functionality\n`;
                updateComment += `- [ ] Investigate failure cause\n`;
                updateComment += `- [ ] Create incident ticket\n`;
                updateComment += `- [ ] Fix migration issues\n`;
                updateComment += `- [ ] Retry deployment when ready\n\n`;
                updateComment += `**This CR remains open for retry after issue resolution.**`;
                
                // Add failure label
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: matchingIssue.number,
                  labels: ['deployment-failed', 'needs-investigation']
                });
              }
              
              // Add comment to the CR
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: matchingIssue.number,
                body: updateComment
              });
              
              console.log(`Updated CR #${matchingIssue.number} with deployment status`);
            } else {
              console.log('No matching CR found for this deployment');
            }
